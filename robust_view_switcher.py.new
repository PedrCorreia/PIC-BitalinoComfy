#!/usr/bin/env python
"""
PIC-2025 Visualization Interface

A lightweight UI for visualizing PIC-2025 signals with tabs for different view modes.
Features:
- Status bar at the top
- Sidebar with tabs (RAW, PROCESSED, TWIN, SETTINGS)
- Signal connection indicators
"""

import os
import sys
import time
import threading
import logging
import pygame
import numpy as np
from enum import Enum

# Add project root to path to ensure imports work
base_dir = os.path.dirname(os.path.abspath(__file__))
if base_dir not in sys.path:
    sys.path.insert(0, base_dir)

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('PIC-2025-UI')

# --- Try to import modules and constants ---
# First try to import ViewMode
try:
    from src.plot.view_mode import ViewMode
    logger.info("Imported ViewMode from src.plot.view_mode")
except ImportError:
    try:
        from plot.view_mode import ViewMode
        logger.info("Imported ViewMode from plot.view_mode")
    except ImportError:
        # Define local fallback if import fails
        class ViewMode(Enum):
            RAW = 0
            PROCESSED = 1
            TWIN = 2
            STACKED = 3
            SETTINGS = 4
        logger.info("Using local fallback ViewMode enum")

# Try to import constants
try:
    from src.plot.constants import (
        WINDOW_WIDTH, WINDOW_HEIGHT, SIDEBAR_WIDTH, STATUS_BAR_HEIGHT,
        BACKGROUND_COLOR, SIDEBAR_COLOR, TEXT_COLOR, OK_COLOR,
        VIEW_MODE_RAW, VIEW_MODE_PROCESSED, VIEW_MODE_TWIN, VIEW_MODE_SETTINGS,
        DEFAULT_FONT, DEFAULT_FONT_SIZE
    )
    logger.info("Imported constants from src.plot.constants")
except ImportError:
    try:
        from plot.constants import (
            WINDOW_WIDTH, WINDOW_HEIGHT, SIDEBAR_WIDTH, STATUS_BAR_HEIGHT,
            BACKGROUND_COLOR, TEXT_COLOR, SIDEBAR_COLOR, OK_COLOR,
            VIEW_MODE_RAW, VIEW_MODE_PROCESSED, VIEW_MODE_TWIN, VIEW_MODE_SETTINGS,
            DEFAULT_FONT, DEFAULT_FONT_SIZE
        )
        logger.info("Imported constants from plot.constants")
    except ImportError:
        # Fallback constants
        logger.warning("Using fallback constants")
        WINDOW_WIDTH = 900
        WINDOW_HEIGHT = 600
        SIDEBAR_WIDTH = 80
        STATUS_BAR_HEIGHT = 32
        BACKGROUND_COLOR = (30, 30, 30)
        SIDEBAR_COLOR = (40, 40, 60)
        TEXT_COLOR = (220, 220, 220)
        OK_COLOR = (0, 255, 0)
        VIEW_MODE_RAW = "RAW"
        VIEW_MODE_PROCESSED = "PROCESSED" 
        VIEW_MODE_TWIN = "TWIN"
        VIEW_MODE_SETTINGS = "SETTINGS"
        DEFAULT_FONT = "consolas"
        DEFAULT_FONT_SIZE = 16

# Additional UI constants that might not be in constants.py
BG_COLOR = BACKGROUND_COLOR  # Mapping to our variable names
FONT_COLOR = TEXT_COLOR
DOT_ON = OK_COLOR
DOT_OFF = (80, 80, 80)
TAB_COLOR = (80, 80, 120)
TAB_SELECTED = (120, 120, 180)
STATUS_COLOR = (50, 50, 80)  # Default if not imported

# Try to import PlotUnit
try:
    from src.plot.plot_unit import PlotUnit
    logger.info("Imported PlotUnit from src.plot.plot_unit")
except ImportError:
    try:
        from plot.plot_unit import PlotUnit
        logger.info("Imported PlotUnit from plot.plot_unit")
    except ImportError:
        logger.error("Could not import PlotUnit")
        sys.exit(1)

# Try to import PlotRegistry
try:
    from src.registry.plot_registry import PlotRegistry
    logger.info("Imported PlotRegistry from src.registry.plot_registry")
except ImportError:
    try:
        from registry.plot_registry import PlotRegistry
        logger.info("Imported PlotRegistry from registry.plot_registry")
    except ImportError:
        logger.error("Could not import PlotRegistry")
        sys.exit(1)

# Define the 4 tabs using view mode constants
TABS = [
    (VIEW_MODE_RAW, ViewMode.RAW),
    (VIEW_MODE_PROCESSED, ViewMode.PROCESSED),
    (VIEW_MODE_TWIN, ViewMode.TWIN),
    (VIEW_MODE_SETTINGS, ViewMode.SETTINGS),
]

# --- Helper Functions ---
def get_registry_instance():
    """Get the PlotRegistry instance."""
    try:
        registry = PlotRegistry.get_instance()
        return registry
    except Exception as e:
        logger.error(f"Error getting registry: {e}")
        return None

def get_registry_signals():
    """Get signals from the registry with error handling."""
    registry = get_registry_instance()
    if not registry or not hasattr(registry, 'signals'):
        return {}
    
    try:
        return registry.signals.copy()
    except Exception as e:
        logger.error(f"Error getting signals: {e}")
        return {}

def register_demo_signals():
    """Create demo signals for testing."""
    registry = get_registry_instance()
    if not registry:
        return False
    
    try:
        # Check if we already have signals
        if hasattr(registry, 'signals') and registry.signals:
            logger.info("Registry already has signals")
            return True
            
        logger.info("Creating demo signals")
        duration = 10.0
        sample_rate = 100
        t = np.linspace(0, duration, int(duration * sample_rate))
        
        # Create some basic signals
        registry.register_signal('ECG_RAW', 0.8 * np.sin(2 * np.pi * 0.5 * t), {
            'name': 'ECG Raw', 
            'color': (255, 0, 0),
            'type': 'raw'
        })
        
        registry.register_signal('RESP_RAW', 0.7 * np.sin(0.3 * np.pi * t), {
            'name': 'Respiration Raw', 
            'color': (0, 0, 255),
            'type': 'raw'
        })
        
        # Create processed versions
        registry.register_signal('PROC_ECG', 0.8 * np.sin(2 * np.pi * 0.5 * t + 0.2), {
            'name': 'ECG Processed', 
            'color': (200, 100, 100),
            'type': 'processed'
        })
        
        registry.register_signal('PROC_RESP', 0.7 * np.sin(0.3 * np.pi * t + 0.1), {
            'name': 'Resp Processed', 
            'color': (100, 100, 200),
            'type': 'processed'
        })
        
        logger.info("Demo signals created")
        return True
    except Exception as e:
        logger.error(f"Error creating signals: {e}")
        return False

# --- Main UI App ---
def main():
    """Main UI application for PIC-2025 visualization."""
    print("\n=== PIC-2025 Visualization Interface ===\n")
    
    pygame.init()
    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
    pygame.display.set_caption("PIC-2025 Visualization")
    
    # Set up font
    font = pygame.font.SysFont(DEFAULT_FONT, DEFAULT_FONT_SIZE)
    clock = pygame.time.Clock()

    # Initialize PlotUnit
    try:
        # Get the singleton instance
        plot_unit = PlotUnit.get_instance()
        
        # Configure dimensions
        if hasattr(plot_unit, 'width'):
            plot_unit.width = WINDOW_WIDTH
        if hasattr(plot_unit, 'height'):
            plot_unit.height = WINDOW_HEIGHT
        if hasattr(plot_unit, 'sidebar_width'):
            plot_unit.sidebar_width = SIDEBAR_WIDTH
        if hasattr(plot_unit, 'status_bar_height'):
            plot_unit.status_bar_height = STATUS_BAR_HEIGHT
            
        # Re-calculate plot_width if available
        if hasattr(plot_unit, 'plot_width'):
            plot_unit.plot_width = WINDOW_WIDTH - SIDEBAR_WIDTH
        
        # Set running flag to True
        if hasattr(plot_unit, 'running'):
            plot_unit.running = True
        
        # Create data lock if needed
        if not hasattr(plot_unit, 'data_lock'):
            plot_unit.data_lock = threading.Lock()
            
        # Create empty data dictionary if needed
        if not hasattr(plot_unit, 'data'):
            plot_unit.data = {}
        
        # Start visualization thread
        if hasattr(plot_unit, 'start') and callable(plot_unit.start):
            if not getattr(plot_unit, 'initialized', False):
                plot_unit.start()
                logger.info("PlotUnit visualization started")
            else:
                logger.info("PlotUnit already initialized")
        else:
            logger.error("PlotUnit has no start method")
            return
    except Exception as e:
        logger.error(f"Error initializing PlotUnit: {e}")
        return

    # Create demo signals
    register_demo_signals()
    
    # UI state variables
    selected_tab = 0  # Start with RAW view
    running = True
    signal_thread = None
    stop_signal_thread = threading.Event()
    connection_status = [False] * len(TABS)
    last_fps = 0
    signal_count = 0
    current_view_mode = ViewMode.RAW

    def signal_updater(tab_idx):
        """Background thread to update signals for the current view."""
        while not stop_signal_thread.is_set():
            try:
                signals = get_registry_signals()
                
                with plot_unit.data_lock:
                    plot_unit.data.clear()
                    
                    # Get the ViewMode for this tab
                    view_mode = TABS[tab_idx][1]
                    
                    # RAW view
                    if view_mode == ViewMode.RAW:  
                        for k, v in signals.items():
                            if not k.startswith("PROC_") and "_processed" not in k:
                                plot_unit.data[k] = np.copy(v)
                    
                    # PROCESSED view
                    elif view_mode == ViewMode.PROCESSED:  
                        for k, v in signals.items():
                            if k.startswith("PROC_") or "_processed" in k:
                                plot_unit.data[k] = np.copy(v)
                    
                    # TWIN view
                    elif view_mode == ViewMode.TWIN:  
                        for k, v in signals.items():
                            plot_unit.data[k] = np.copy(v)
                    
                    # SETTINGS view doesn't need signals
                    elif view_mode == ViewMode.SETTINGS:
                        # Just add a minimal diagnostic signal
                        t = np.linspace(0, 2, 100)
                        plot_unit.data["SETTINGS_DIAGNOSTIC"] = np.sin(2 * np.pi * t)
                
                connection_status[tab_idx] = True
                time.sleep(0.5)  # Update twice per second
            except Exception as e:
                logger.error(f"Error in signal updater: {e}")
                connection_status[tab_idx] = False
                time.sleep(1.0)  # Longer delay on error

    def start_signal_thread(tab_idx):
        """Start the background signal update thread."""
        nonlocal signal_thread, stop_signal_thread, current_view_mode
        
        # Clean up existing thread if any
        stop_signal_thread.set()
        if signal_thread and signal_thread.is_alive():
            signal_thread.join(timeout=1.0)
        
        # Get target mode
        target_mode = TABS[tab_idx][1]
        
        # Set the view mode
        try:
            if hasattr(plot_unit, '_set_mode'):
                plot_unit._set_mode(target_mode)
                logger.info(f"Set view mode to {target_mode.name} using _set_mode")
            else:
                # Fall back to setting attributes directly
                if hasattr(plot_unit, 'current_mode'):
                    plot_unit.current_mode = target_mode
                
                # Update sidebar if available
                if hasattr(plot_unit, 'sidebar') and plot_unit.sidebar:
                    plot_unit.sidebar.current_mode = target_mode
                
                # Update event handler if available
                if hasattr(plot_unit, 'event_handler') and plot_unit.event_handler:
                    plot_unit.event_handler.current_mode = target_mode
                
                logger.info(f"Set view mode to {target_mode.name} using attribute access")
        except Exception as e:
            logger.error(f"Error setting view mode: {e}")
        
        # Update current mode
        current_view_mode = target_mode
        
        # Start new signal thread
        stop_signal_thread = threading.Event()
        signal_thread = threading.Thread(target=signal_updater, args=(tab_idx,), daemon=True)
        signal_thread.start()
        
        logger.info(f"Changed view mode to {TABS[tab_idx][0]}")

    def stop_signal_updates():
        """Safely stop the signal update thread."""
        nonlocal stop_signal_thread, signal_thread
        
        stop_signal_thread.set()
        if signal_thread and signal_thread.is_alive():
            signal_thread.join(timeout=1.0)
        
        # Clear all signals
        try:
            with plot_unit.data_lock:
                plot_unit.data.clear()
        except Exception as e:
            logger.error(f"Error clearing data: {e}")
        
        # Reset connection status
        for i in range(len(connection_status)):
            connection_status[i] = False

    # Start with RAW view
    start_signal_thread(selected_tab)

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mx, my = pygame.mouse.get_pos()
                
                # Check for tab clicks in sidebar
                tab_height = 60
                for i, (label, _) in enumerate(TABS):
                    tab_y = 50 + i*tab_height
                    if 0 <= mx < SIDEBAR_WIDTH and tab_y <= my < tab_y + tab_height:
                        if selected_tab != i:
                            # Switch tabs
                            logger.info(f"User clicked on {label} tab")
                            stop_signal_updates()
                            selected_tab = i
                            start_signal_thread(selected_tab)
        
        # Update metrics
        if hasattr(plot_unit, 'fps_counter') and hasattr(plot_unit.fps_counter, 'get_fps'):
            try:
                last_fps = plot_unit.fps_counter.get_fps()
            except Exception:
                last_fps = 0
        
        try:
            signal_count = len(plot_unit.data)
        except Exception:
            signal_count = 0
        
        # Draw background
        screen.fill(BG_COLOR)
        
        # Draw sidebar
        pygame.draw.rect(screen, SIDEBAR_COLOR, (0, 0, SIDEBAR_WIDTH, WINDOW_HEIGHT))
        
        # Draw tabs
        tab_height = 60
        for i, (label, _) in enumerate(TABS):
            tab_y = 50 + i*tab_height
            
            # Tab background
            color = TAB_SELECTED if i == selected_tab else TAB_COLOR
            pygame.draw.rect(screen, color, (5, tab_y, SIDEBAR_WIDTH-10, tab_height-10))
            
            # Tab label
            txt = font.render(label, True, FONT_COLOR)
            screen.blit(txt, (SIDEBAR_WIDTH//2 - txt.get_width()//2, tab_y + 10))
            
            # Connection indicator dot
            dot_color = DOT_ON if connection_status[i] else DOT_OFF
            pygame.draw.circle(screen, dot_color, (SIDEBAR_WIDTH//2, tab_y + 40), 6)
        
        # Draw status bar
        pygame.draw.rect(screen, STATUS_COLOR, (0, 0, WINDOW_WIDTH, STATUS_BAR_HEIGHT))
        status = f"Mode: {TABS[selected_tab][0]} | Signals: {signal_count} | FPS: {int(last_fps)}"
        txt = font.render(status, True, FONT_COLOR)
        screen.blit(txt, (10, 6))
        
        # Update display
        pygame.display.flip()
        clock.tick(30)
    
    # Clean up before exit
    stop_signal_updates()
    pygame.quit()
    logger.info("UI shut down")

if __name__ == "__main__":
    main()
